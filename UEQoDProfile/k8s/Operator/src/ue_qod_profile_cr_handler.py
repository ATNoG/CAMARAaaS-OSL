import kopf
from kubernetes import client, config, watch
from kubernetes.client import CoreV1Api
import requests
import json 

from config import Config
from itav_network_slice_manager import ITAvNetworkSliceManager

# Set up logging
logger = Config.setup_logging()

class UEQoDProfileCRHandler:

    def __init__(
        self,
        slice_manager: ITAvNetworkSliceManager,
        custom_objects_api: CoreV1Api
    ):
        self.slice_manager = slice_manager
        self.custom_objects_api = custom_objects_api
        
    def process_ue_qod_profle_event(
        self, event: str, spec: dict, metadata: dict
        ) -> None:

        cr_name = metadata['name']
        cr_namespace = metadata['namespace']

        if event == "ADD":
            logger.info(
                f"A resource with group: {Config.cr_group}, "
                f"version: {Config.cr_version}, plural: {Config.cr_plural} "
                f"was CREATED. This resource is named '{cr_name}' and was "
                f"deployed in namespace '{cr_namespace}'. Will now parse this "
                "resource and  request the creation of a QoD UE Profile via "
                f"ITAvNetworkSliceManager (url={self.slice_manager.base_url})"
                f"Resource: {spec}"
            )
            
            self._process_init(cr_namespace, cr_name)
            return
            
        elif event == "UPDATE":
            logger.info(
            f"A resource with group: {Config.cr_group}, "
            f"version: {Config.cr_version}, plural: {Config.cr_plural} "
            f"was UPDATED. This resource is named '{cr_name}' and was "
            f"deployed in namespace '{cr_namespace}'. "
            f"Resource: {spec}"
        )
        
        # If there is not a new profile to apply, stop
        if not spec["qodProv"]["newQoDProvToApply"]:
            logger.info("It is not required to provision a new QoD profile.")
            return
        
        tmp_result = self._spec_qod_prov_to_tmp_result(spec)

        self._process_qod_provisioning_request(
            cr_namespace, cr_name, spec, tmp_result
        )
        
                
            
        
        

        # Make request to the Slice Manager
        #should_apply_cr, enforcement_result = self.slice_manager \
        #    .create_network_slice_ue(
        #        spec, self._spec_params_to_ue_patch_payload(spec)
        #    )
        #
        #if should_apply_cr:
        #    self.process_network_slice_ue_enforcement(
        #        cr_namespace, cr_name, enforcement_result
        #    )
    
    def _process_qod_provisioning_request (
        self, cr_namespace, cr_name, spec, tmp_result
    ):  
        # Check if profile exists
        # If the profile does not exist, set the status as UNAVAILABLE,
        # update the results, and return
        if spec["qodProv"]["qosProfile"] \
        not in spec["ITAvSliceManager"]["profiles"]:
            logger.info(
                f"The profile {spec['qodProv']['qosProfile']} does not exist!"
            )
            tmp_result["status"] = "UNAVAILABLE"
            self._process_results_update(
                cr_namespace, cr_name, spec, tmp_result
            )
            return
        
        # If the profile exists, try to apply it via the Slice Manager
        
        
    
    def _spec_qod_prov_to_tmp_result(self, spec):
        qod_prov = spec["qodProv"]
        del qod_prov["newQoDProvToApply"]
        return qod_prov
    
    def _spec_params_to_ue_patch_payload(self, spec):

        qod_prov = spec["qodProv"]
        net_slice = spec["ITAvSliceManager"]["slice"]
        profiles = spec["ITAvSliceManager"]["profiles"]

        # Generated by AI
        payload = {
            "IMSI": int(
                qod_prov["device"]["networkAccessIdentifier"]\
                .split("@")[0]
            ),
            "numIMSIs": 1,
            "slice": net_slice,
            "IPV4": "",
            "IPV6":  "",
            "AMDATA": True,
            "DEFAULT": "TRUE",
            "UEcanSendSNSSAI": "TRUE",
            "AMBRUP": int(
                profiles.get(qod_prov["qosProfile"]).get("AMBRUP")
            ),
            "AMBRDW": int(
                profiles.get(qod_prov["qosProfile"]).get("AMBRDW")
            )
        }

        # Remove any keys where the value is None
        payload = {k: v for k, v in payload.items() if v is not None}

        logger.info(
            "JSON Payload for the Slice Manager: "
            f"{json.dumps(payload, indent=4)}"
        )

        return payload


    def _process_init(
        self, namespace: str, name: str
        ) -> None:

        patch = {
            "spec": {
                "status": "RUNNING"
            }
        }
    
        try:
            # Apply the patch to update 'spec.data2' of the custom resource
            self.custom_objects_api.patch_namespaced_custom_object(
                group=Config.cr_group,
                version=Config.cr_version,
                namespace=namespace,
                plural=Config.cr_plural,
                name=name,
                body=patch
            )
            logger.info(
                f"Updated 'spec.status' for {name} in "
                f"{namespace} to RUNNING")

        except client.exceptions.ApiException as e:
            logger.error(
                "Exception when updating 'spec.status' "
                f"in custom resource: {e}")
            
    def _process_results_update(
        self, namespace: str, name: str, spec: dict, result: dict
        ) -> None:
        
        # Get Current Results
        current_results = spec["camaraResults"]
        current_results.append(result)
        patch = {
            "spec": {
                "qodProv": {
                    "newQoDProvToApply": False
                },
                "camaraResults": current_results
            }
        }
    
        try:
            # Apply the patch to update 'spec.data2' of the custom resource
            self.custom_objects_api.patch_namespaced_custom_object(
                group=Config.cr_group,
                version=Config.cr_version,
                namespace=namespace,
                plural=Config.cr_plural,
                name=name,
                body=patch
            )
            logger.info(
                f"Updated 'spec.camaraResults' for {name} in "
                f"{namespace} to RUNNING")

        except client.exceptions.ApiException as e:
            logger.error(
                "Exception when updating 'spec.camaraResults' "
                f"in custom resource: {e}")
            
    
    def process_network_slice_ue_enforcement(
        self, namespace: str, name: str, enforcement_result: dict
        ) -> None:

        patch = {
            "spec": {
                "network-slice-ue-enforcement": enforcement_result
            }
        }
    
        try:
            # Apply the patch to update 'spec.data2' of the custom resource
            self.custom_objects_api.patch_namespaced_custom_object(
                group=Config.cr_group,
                version=Config.cr_version,
                namespace=namespace,
                plural=Config.cr_plural,
                name=name,
                body=patch
            )
            logger.info(
                f"Updated 'spec.network-slice-ue-enforcement' for {name} in "
                f"{namespace} to {enforcement_result}")

        except client.exceptions.ApiException as e:
            logger.error(
                "Exception when updating 'spec.network-slice-ue-enforcement' "
                f"in custom resource: {e}")
    

